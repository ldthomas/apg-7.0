/*  *************************************************************************************
    Copyright (c) 2021, Lowell D. Thomas
    All rights reserved.
    
    This file is part of APG Version 7.0.
    APG Version 7.0 may be used under the terms of the BSD 2-Clause License.
    
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
    
    1. Redistributions of source code must retain the above copyright notice, this
       list of conditions and the following disclaimer.
    
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation
       and/or other materials provided with the distribution.
    
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    
*   *************************************************************************************/
/** \file parser.c
 * \brief The SABNF parser.
 */

#include "./lib.h"
#include "./parserp.h"
#include "./operators.h"
#ifdef APG_TRACE
#include "./tracep.h"
#include "./statsp.h"
#endif
#ifdef APG_STATS
#include "./statsp.h"
#endif
#ifdef APG_BKR
#include "./backref.h"
#include "./backrefu.h"
#include "./backrefp.h"
#endif

static const void* s_vpMagicNumber = (void*)"parser";

//#define PARSER_DEBUG 1
#ifdef PARSER_DEBUG
#include <stdio.h>
#include "../utilities/utilities.h"
#endif /* PARSER_DEBUG */

/** \brief The parser's constructor for file initialization data.
 *
 *
 * This function is used to construct a parser from grammar file, "namespace.c", generated by vApiOutput().
 * \param spException Pointer to a valid exception structure initialized with vExCtor() or \ref XCTOR().
 * If not valid, the application will silently exit with a \ref BAD_CONTEXT exit code.
 * \param vpParserInit - Pointer to the initialization data in the generated "namespace.c" file.
 * \return Pointer to a parser context. Exceptions thrown on errors.
 */
void* vpParserCtor(exception* spException, void* vpParserInit) {
    return vpParserAllocCtor(spException, vpParserInit, APG_FALSE);
}

/** \brief The parser constructor.
 *
 * The generator can generate the parser's initialization data in one of two ways.
 *  - With vApiOutput() the data is in an C-language code file, "namespace.c".
 * When constructing a parser from the file data, no further memory allocations for it are necessary.
 *  - With vpApiOutputParser() the data is in the API object's context and must be copied to the parser's context
 *  to separate it completely from the API. That is, the parser's context must remain complete and valid
 *  even if the API context is destroyed.
 * This function has a switch to chose between the two.
 *
 * \param spException Pointer to a valid exception structure initialized with vExCtor() or \ref XCTOR().
 * If not valid, the application will silently exit with a \ref BAD_CONTEXT exit code.
 * \param vpParserInit Pointer to the initialization data.
 * \param bAllocateTables If true, memory is allocated to copy the initialization data into the parser'scontext.
 *                        If false, no memory allocation and copying is done.
 * \return Pointer to a parser context. Exceptions thrown on errors.
 */
void* vpParserAllocCtor(exception* spException, void* vpParserInit, abool bAllocateTables){
    if(!bExValidate(spException)){
        vExContext();
        return NULL;
    }
    // validate the size of the alphabet character (achar)
    parser_init* spParserInit = (parser_init*) vpParserInit;
    init_hdr* spInitHdr = NULL;
    luint* luipParserInit = NULL;
    aint* uipChildList = NULL;
    achar* acpAcharTable = NULL;
    parser* spCtx = NULL;
    void* vpMem = NULL;
    if ((uint32_t) sizeof(achar) < spParserInit->uiSizeofAchar) {
        XTHROW(spException, "sizeof(achar) is too small for this parser's grammar");
    }
    // validate the size of the working unsigned int (aint)
    // note: uiSizeofUint is the integer size of the maximum integer in the initialization data.
    //       Since achar max is in the data, it stands that sizeof(aint) >= sizeof(achar) always.
    if ((uint32_t) sizeof(aint) < spParserInit->uiSizeofUint) {
        XTHROW(spException, "sizeof(aint) is too small for this parser's maximum integer");
    }
    // get the parser context
    vpMem = vpMemCtor(spException);
    spCtx = (parser*) vpMemAlloc(vpMem, (aint) sizeof(parser));
    memset((void*) spCtx, 0, sizeof(parser));
    spCtx->vpMem = vpMem;
    spCtx->spException = spException;

    if(bAllocateTables){
        size_t uiAlloc;
        // allocate and copy the string table
        uiAlloc = sizeof(char) * (size_t)spParserInit->uiStringTableLength;
        char* cpStr = (char*)vpMemAlloc(vpMem, uiAlloc);
        memcpy(cpStr, spParserInit->cpStringTable, uiAlloc);
        spCtx->cpStringTable = (const char*)cpStr;
        // allocate and copy the PPPT maps table
        spCtx->ucpMaps = NULL;
        if(spParserInit->ucpPpptTable){
            uiAlloc = sizeof(uint8_t) * (size_t)spParserInit->uiPpptTableLength;
            uint8_t* ucpStr = (uint8_t*)vpMemAlloc(vpMem, uiAlloc);
            memcpy(ucpStr, spParserInit->ucpPpptTable, uiAlloc);
            spCtx->ucpMaps = (const uint8_t*)ucpStr;
        }
    }else{
        // get the string table
        spCtx->cpStringTable = spParserInit->cpStringTable;

        // get the PPPT maps table
        spCtx->ucpMaps = spParserInit->ucpPpptTable;
    }

    // get the achar table
    if(spParserInit->uiAcharTableLength){
        acpAcharTable = (achar*) vpMemAlloc(vpMem, (aint)(spParserInit->uiAcharTableLength * sizeof(achar)));
        if (!uiGetAcharTable(spParserInit, acpAcharTable)) {
            XTHROW(spMemException(spCtx->vpMem), "invalid achar table data");
        }
        spCtx->acpAcharTable = acpAcharTable;
    }

    // get the parser initialization data in uints
    luipParserInit = (luint*) vpMemAlloc(vpMem, (aint)(spParserInit->uiParserInitLength * sizeof(luint)));
    if (!bGetParserInitData(spParserInit, luipParserInit)) {
        XTHROW(spMemException(spCtx->vpMem), "invalid parser initialization data");
    }
    spInitHdr = (init_hdr*) luipParserInit;
    spCtx->acAcharMin = (achar)spInitHdr->uiAcharMin;
    spCtx->acAcharMax = (achar)spInitHdr->uiAcharMax;
    spCtx->uiMapSize = spInitHdr->uiMapSize;
    spCtx->uiMapCount = spInitHdr->uiMapCount;
    spCtx->vpVecInputString = vpVecCtor(vpMem, sizeof(achar), 2048);

    // get the child list (opcode indexes for children of ALT and CAT)
    uipChildList = (aint*) vpMemAlloc(vpMem, (aint) (sizeof(aint) * spInitHdr->uiChildListLength));
    vGetChildListTable(spInitHdr, uipChildList);
    spCtx->uipChildList = (const aint*) uipChildList;

    // allocate rules
    spCtx->uiRuleCount = (aint) spInitHdr->uiRuleCount;
    spCtx->spRules = (rule*) vpMemAlloc(vpMem, (aint) (sizeof(rule) * spCtx->uiRuleCount));
    memset((void*)spCtx->spRules, 0, (sizeof(rule) * spCtx->uiRuleCount));

    // allocate udts
    spCtx->uiUdtCount = (aint) spInitHdr->uiUdtCount;
    if (spCtx->uiUdtCount) {
        spCtx->spUdts = (udt*) vpMemAlloc(vpMem, (aint) (sizeof(udt) * spCtx->uiUdtCount));
        memset((void*)spCtx->spUdts, 0, (sizeof(udt) * spCtx->uiUdtCount));
    }

    // allocate opcodes
    spCtx->uiOpcodeCount = (aint) spInitHdr->uiOpcodeCount;
    spCtx->spOpcodes = (opcode*) vpMemAlloc(vpMem, (aint) (sizeof(opcode) * spCtx->uiOpcodeCount));
    memset((void*)spCtx->spOpcodes, 0, (sizeof(opcode) * spCtx->uiOpcodeCount));

    // get the rules, UDTs, and opcodes
    vTranslateRules(spCtx, spCtx->spRules, spCtx->spOpcodes, (luipParserInit + spInitHdr->uiRulesOffset));
    vTranslateUdts(spCtx, spCtx->spUdts, (luipParserInit + spInitHdr->uiUdtsOffset));
    vTranslateOpcodes(spCtx, spCtx->spRules, spCtx->spUdts, spCtx->spOpcodes,
            (luipParserInit + spInitHdr->uiOpcodesOffset));
    vMemFree(vpMem, luipParserInit);

    // allocate and set the array of operator function pointers
    // NOTE: ID_GEN must be greater than all other opcode IDs
    spCtx->pfnOpFunc = (pfn_op*) vpMemAlloc(vpMem, (aint) (sizeof(pfn_op) * ID_GEN));
    spCtx->pfnOpFunc[ID_ALT] = vAlt;
    spCtx->pfnOpFunc[ID_CAT] = vCat;
    spCtx->pfnOpFunc[ID_REP] = vRep;
    spCtx->pfnOpFunc[ID_RNM] = vRnm;
    spCtx->pfnOpFunc[ID_TRG] = vTrg;
    spCtx->pfnOpFunc[ID_TLS] = vTls;
    spCtx->pfnOpFunc[ID_TBS] = vTbs;
#ifdef APG_BKR
    spCtx->pfnOpFunc[ID_BKR] = vBkr;
#else
    spCtx->pfnOpFunc[ID_BKR] = NULL;
#endif /* APG_BKR */
#ifdef APG_STRICT_ABNF
    spCtx->pfnOpFunc[ID_UDT] = NULL;
    spCtx->pfnOpFunc[ID_AND] = NULL;
    spCtx->pfnOpFunc[ID_NOT] = NULL;
    spCtx->pfnOpFunc[ID_BKA] = NULL;
    spCtx->pfnOpFunc[ID_BKN] = NULL;
    spCtx->pfnOpFunc[ID_ABG] = NULL;
    spCtx->pfnOpFunc[ID_AEN] = NULL;
#else
    spCtx->pfnOpFunc[ID_UDT] = vUdt;
    spCtx->pfnOpFunc[ID_AND] = vAnd;
    spCtx->pfnOpFunc[ID_NOT] = vNot;
    spCtx->pfnOpFunc[ID_BKA] = vBka;
    spCtx->pfnOpFunc[ID_BKN] = vBkn;
    spCtx->pfnOpFunc[ID_ABG] = vAbg;
    spCtx->pfnOpFunc[ID_AEN] = vAen;
#endif /* APG_STRICT_ABNF */

    spCtx->vpBkru = BKRU_CTOR(spCtx);
    spCtx->vpBkrp = BKRP_CTOR(spCtx);

#ifdef PARSER_DEBUG
    printf("\n");
    vPrintRules(spCtx, NULL);
    printf("\n");
    vPrintUdts(spCtx, NULL);
    printf("\n");
    vPrintOpcodes(spCtx, NULL);
#endif /* PARSER_DEBUG */

    // success, return the parser context handle (pointer)
    spCtx->vpValidate = s_vpMagicNumber;
    return (void*) spCtx;
}

/** \brief Clears the parser component's context and frees all heap memory associated with this parser.
 *
 * \param vpCtx a parser context pointer previously returned from \ref vpParserCtor() or vpApiOutputParser().
 * NULL is silently ignored. However, non-NULL values must be valid parser context pointers.
 */
void vParserDtor(void* vpCtx) {
    parser* spCtx = (parser*) vpCtx;
    if(vpCtx){
        if (spCtx->vpValidate == s_vpMagicNumber) {
            void* vpMem = spCtx->vpMem;
            TRACE_DTOR(spCtx->vpTrace);
            memset((void*)spCtx, 0, sizeof(*spCtx));
            vMemDtor(vpMem);
        }else{
            vExContext();
        }
    }
}

/** \brief Parse an input string of alphabet characters.
 *
 * \param vpCtx Pointer to a valid parser context previously returned from \ref vpParserCtor() or vpApiOutputParser().
 * If not valid, the application will silently exit with a \ref BAD_CONTEXT exit code.
 * \param spConfig Pointer to the configuration defining the input string and other parsing parameters. See \ref parser_config.
 * \param spState Pointer to a parser state structure. See \ref parser_state.
 * \return The parser state is returned in the caller's state structure, spState.
 *
 */
void vParserParse(void* vpCtx, parser_config* spConfig, parser_state* spState) {
    parser* spCtx = (parser*) vpCtx;
    aint ui;
    if(!vpCtx || (spCtx->vpValidate != s_vpMagicNumber)){
        vExContext();
        return; // should never return
    }
    if(!spConfig){
        XTHROW(spMemException(spCtx->vpMem), "parser configuration pointer cannot be NULL");
        return; // should never return
    }
    if(!spState){
        XTHROW(spMemException(spCtx->vpMem), "parser state pointer cannot be NULL");
        return; // should never return
    }
    // validate the input
    if (!spConfig->acpInput) {
        XTHROW(spMemException(spCtx->vpMem), "input string is NULL");
    }
    if (spConfig->uiStartRule >= spCtx->uiRuleCount) {
        XTHROW(spMemException(spCtx->vpMem), "start rule is out of range");
    }
    memset(spState, 0, sizeof(*spState));

    // verify all UDT callbacks set
    if (spCtx->uiUdtCount) {
        for (ui = 0; ui < spCtx->uiUdtCount; ui += 1) {
            if (spCtx->spUdts[ui].pfnCallback == NULL) {
                XTHROW(spCtx->spException,
                        "NULL UDT callback function pointers - all UDT callback functions must be set");
            }
        }
    }

    vVecClear(spCtx->vpVecInputString);
    spCtx->acpInputString = (achar*)vpVecPushn(spCtx->vpVecInputString, (void*)spConfig->acpInput, spConfig->uiInputLength);
    spCtx->uiInputStringLength = spConfig->uiInputLength;
    spCtx->uiStartRule = spConfig->uiStartRule;
    if (spConfig->bParseSubString) {
        // set the beginning and end of the sub string
        if (spConfig->uiSubStringBeg >= spCtx->uiInputStringLength) {
            XTHROW(spMemException(spCtx->vpMem), "sub string beginning is beyond the end of the input string");
        }
        spCtx->uiSubStringBeg = spConfig->uiSubStringBeg;
        if (spConfig->uiSubStringLength == 0) {
            spCtx->uiSubStringEnd = spCtx->uiInputStringLength;
        } else {
            spCtx->uiSubStringEnd = spCtx->uiSubStringBeg + spConfig->uiSubStringLength;
            if(spCtx->uiSubStringEnd > spConfig->uiInputLength){
                spCtx->uiSubStringEnd = spConfig->uiInputLength;
            }
        }
    } else {
        // parse the entire string
        spCtx->uiSubStringBeg = 0;
        spCtx->uiSubStringEnd = spConfig->uiInputLength;
    }
    spCtx->uiSubStringLength = spCtx->uiSubStringEnd - spCtx->uiSubStringBeg;
    spCtx->uiOffset = spCtx->uiSubStringBeg;

    // initialize the maximum distance to look behind for operators BKA & BKN
    if ((spConfig->uiLookBehindLength == 0) || (spConfig->uiLookBehindLength == APG_INFINITE)) {
        spCtx->uiLookBehindLength = spCtx->uiInputStringLength;
    } else {
        spCtx->uiLookBehindLength = spCtx->uiInputStringLength < spCtx->uiLookBehindLength ?
                spCtx->uiInputStringLength : spCtx->uiLookBehindLength;
    }

    // initialize the callback data (callback functions only see the substring)
    spCtx->sCBData.vpCtx = (void*) spCtx;
    spCtx->sCBData.vpMem = spCtx->vpMem;
    spCtx->sCBData.spException = spCtx->spException;
    spCtx->sCBData.acpString = &spCtx->acpInputString[spCtx->uiSubStringBeg];
    spCtx->sCBData.uiStringLength = spCtx->uiSubStringLength;
    spCtx->sCBData.uiParserOffset = 0;
    spCtx->sCBData.uiParserState = ID_ACTIVE;
    spCtx->sCBData.uiParserPhraseLength = 0;
    spCtx->sCBData.vpUserData = spConfig->vpUserData;
    spCtx->sCBData.uiCallbackPhraseLength = 0;
    spCtx->sCBData.uiCallbackState = ID_ACTIVE;

    // reset attached trace and AST if any (stats, if any, are cumulative)
    TRACE_BEGIN(spCtx->vpTrace);
    AST_CLEAR(spCtx->vpAst);

    // create a dummy RNM opcode for the start rule and start the parser
    memset((void*)&spCtx->sState, 0, sizeof(spCtx->sState));
    spCtx->uiTreeDepth = 0;
    spCtx->sStartOp.sRnm.spRule = &spCtx->spRules[spCtx->uiStartRule];
    spCtx->sStartOp.sRnm.uiId = ID_RNM;
    spCtx->sStartOp.sRnm.ucpPpptMap = spCtx->spRules[spCtx->uiStartRule].ucpPpptMap;
    spCtx->pfnOpFunc[ID_RNM](spCtx, &spCtx->sStartOp);

    // finish the trace output
    TRACE_END(spCtx->vpTrace);

    // on parsing errors, success depends on the matched phrase length
    spCtx->sState.uiState = spCtx->uiOpState;
    spCtx->sState.uiPhraseLength =
            spCtx->uiOffset > spCtx->uiSubStringBeg ? spCtx->uiOffset - spCtx->uiSubStringBeg : 0;
    spCtx->sState.uiStringLength = spCtx->uiSubStringLength;
    if (spCtx->sState.uiState == ID_NOMATCH) {
        spCtx->sState.uiSuccess = APG_FALSE;
    } else if (spCtx->sState.uiPhraseLength == spCtx->sState.uiStringLength) {
        spCtx->sState.uiSuccess = APG_TRUE;
    } else {
        spCtx->sState.uiSuccess = APG_FALSE;
    }
    memcpy((void*) spState, (void*) &spCtx->sState, sizeof(*spState));
}

/** \brief Set a call back function for a specific rule.
 *
 * \param vpCtx Pointer to a valid parser context previously returned from \ref vpParserCtor() or vpApiOutputParser().
 * If not valid, the application will silently exit with a \ref BAD_CONTEXT exit code.
 * \param uiRuleId The index of the rule to set the call back function for.
 * \param pfnCallback Pointer to the call back function.
 */
void vParserSetRuleCallback(void* vpCtx, aint uiRuleId, parser_callback pfnCallback) {
    parser* spCtx = (parser*) vpCtx;
    if (vpCtx && (spCtx->vpValidate == s_vpMagicNumber)) {
        if (uiRuleId < spCtx->uiRuleCount) {
            spCtx->spRules[uiRuleId].pfnCallback = pfnCallback;
        }
    }else{
        vExContext();
    }
}

/** \brief Set a call back function for a specific UDT.
 *
 * Note that the parser, vParserParse(), checks on initialization that
 * all UDTs in the SABNF grammar have call back functions set.
 *
 * \param vpCtx Pointer to a valid parser context previously returned from \ref vpParserCtor() or vpApiOutputParser().
 * If not valid, the application will silently exit with a \ref BAD_CONTEXT exit code.
 * \param uiUdtId The index of the UDT to set the call back function for.
 * \param pfnCallback Pointer to the call back function.
 */
void vParserSetUdtCallback(void* vpCtx, aint uiUdtId, parser_callback pfnCallback) {
    parser* spCtx = (parser*) vpCtx;
    if (vpCtx && (spCtx->vpValidate == s_vpMagicNumber)) {
        if (uiUdtId < spCtx->uiUdtCount) {
            spCtx->spUdts[uiUdtId].pfnCallback = pfnCallback;
        }
    }else{
        vExContext();
    }
}

/** \brief Validate the context pointer of a parser.
 * \param vpCtx Pointer to a supposedly valid parser context previously returned from \ref vpParserCtor() or vpApiOutputParser().
 * \return True if the context pointer is valid, false otherwise.
 */
abool bParserValidate(void* vpCtx){
    parser* spCtx = (parser*) vpCtx;
    if (vpCtx && (spCtx->vpValidate == s_vpMagicNumber)) {
        return APG_TRUE;
    }
    return APG_FALSE;
}

/** \brief Find the rule index corresponding to a rule name.
 *
 * A rule's index is the 0-based order in which it appears in the SABNF grammar.
 * Used in many places instead of the name to identify a rule.
 * The parser's start rule (\ref parser_config) would be a prime example.
 * \param vpCtx Pointer to a valid parser context previously returned from \ref vpParserCtor() or vpApiOutputParser().
 * If not valid, the application will silently exit with a \ref BAD_CONTEXT exit code.
 * \param cpRuleName Name of the rule to look up. Case insensitive.
 * \return The rule index if successful. \ref APG_UNDEFINED if the name does not appear in the SABNF grammar.
 */
aint uiParserRuleLookup(void* vpCtx, const char* cpRuleName){
    aint uiReturn = APG_UNDEFINED;
    parser* spCtx = (parser*) vpCtx;
    if (!(vpCtx && (spCtx->vpValidate == s_vpMagicNumber))) {
        vExContext();
    }

    // linear search (qsort + binary search overkill here)
    rule* spRule = spCtx->spRules;
    aint ui = 0;
    for(; ui < spCtx->uiRuleCount; ui++, spRule++){
        if(iStriCmp(cpRuleName, spRule->cpRuleName) == 0){
            uiReturn = spRule->uiRuleIndex;
            break;
        }
    }
    return uiReturn;
}

/** \brief Find the rule name from the corresponding index.
 *
 * A rule's index is the 0-based order in which it appears in the SABNF grammar.
 * Used in many places instead of the name to identify a rule.
 * The parser's start rule (\ref parser_config) would be a prime example.
 * \param vpCtx Pointer to a valid parser context previously returned from \ref vpParserCtor() or vpApiOutputParser().
 * If not valid, the application will silently exit with a \ref BAD_CONTEXT exit code.
 * \param uiRuleIndx Index (order of appearance in the SABNF grammar) of the rule name to look up
 * \return Pointer to the rule name if successful. \ref NULL if the index is out of range.
 */
const char* cpParserRuleName(void* vpCtx, aint uiRuleIndex){
    parser* spCtx = (parser*) vpCtx;
    if (!(vpCtx && (spCtx->vpValidate == s_vpMagicNumber))) {
        vExContext();
    }

    if(uiRuleIndex < spCtx->uiRuleCount){
        return spCtx->spRules[uiRuleIndex].cpRuleName;
    }
    return NULL;
}

/** \brief Find the UDT name corresponding to a UDT index.
 *
 * A UDT's index is the  0-based order in which it appears in the SABNF grammar.
 * Used in some places instead of the name to identify a UDT.
 * vParserSetUdtCallback() would be an example.
 * \param vpCtx Pointer to a valid parser context previously returned from \ref vpParserCtor() or vpApiOutputParser().
 * If not valid, the application will silently exit with a \ref BAD_CONTEXT exit code.
 * \param uiUdtIndex Index of the UDT to look up.
 * \return Pointer to the UDT name if successful. \ref NULL if the index is out of range.
 */
const char* cpParserUdtName(void* vpCtx, aint uiUdtIndex){
    aint uiReturn = APG_UNDEFINED;
    parser* spCtx = (parser*) vpCtx;
    if (!(vpCtx && (spCtx->vpValidate == s_vpMagicNumber))) {
        vExContext();
    }

    if(uiUdtIndex < spCtx->uiUdtCount){
        return spCtx->spUdts[uiUdtIndex].cpUdtName;
    }
    return NULL;
}

#ifndef APG_NO_PPPT
#ifdef PARSER_EVAL_DEBUG
#include <stdio.h>
#include "../utilities/utilities.h"
static const char* cpMapVal(uint8_t ucVal){
    static char* caVal[5] = {"N", "M", "E", "A", "U"};
    if(ucVal < 4){
        return caVal[ucVal];
    }
    return caVal[4];
}
static void vPrintMap(achar acMin, achar acMax, const uint8_t* ucpMap){
    aint ui;
    uint8_t ucVal;
    for(ui = acMin; ui <= acMax; ui++){
        ucVal = ucGetMapVal(ucpMap, acMin, ui);
        if(ucVal != ID_PPPT_NOMATCH){
            printf(" %"PRIuMAX"%s", (luint)ui, cpMapVal(ucVal));
        }
    }
    printf("\n");
}
#endif /* PARSER_EVAL_DEBUG */

/** \brief Private function used only by the parser. User should never call.
 *
 * \param spCtx Pointer to a parser context.
 * \param spOp Pointer to an opcode.
 * \param uiOffset Offset into the input string of the alphabet character to check the PPPT state of.
 * \return The state that the PPPT maps this opcode and character to.
 */
aint uiPpptState(parser* spCtx, const opcode* spOp, aint uiOffset){
    achar acChar;
    uint8_t ucVal;
    if(!spCtx->ucpMaps){
        return ID_ACTIVE;
    }
    switch(spOp->sGen.uiId){
    case ID_BKR:
    case ID_UDT:
    case ID_BKA:
    case ID_BKN:
    case ID_ABG:
    case ID_AEN:
        // no PPPTs for these operators
        return ID_ACTIVE;
    }
    if(uiOffset >= spCtx->uiSubStringEnd){
        if(spCtx->uiSubStringEnd == 0){
            // special case when BKA or BKN look behind at beginning of string
            return ID_NOMATCH;
        }
        // map value for end-of-string character
        ucVal = spOp->sGen.ucpPpptMap[spCtx->acAcharMax + 1 - spCtx->acAcharMin];
    }else{
        acChar = spCtx->acpInputString[uiOffset];
        if(acChar < spCtx->acAcharMin || acChar > spCtx->acAcharMax){
            return ID_NOMATCH;
        }
        ucVal = spOp->sGen.ucpPpptMap[acChar - spCtx->acAcharMin];
    }
#ifdef PARSER_EVAL_DEBUG
    printf("%s: ", cpOpName(spOp->sGen.uiId));
    printf(" %"PRIuMAX"%s: ", (luint)acChar, cpMapVal(ucVal));
    vPrintMap(spCtx->acAcharMin, spCtx->acAcharMax, spOp->sGen.ucpPpptMap);
    fflush(stdout);
#endif /* PARSER_EVAL_DEBUG */
    if(ucVal == ID_PPPT_NOMATCH){
        return ID_NOMATCH;
    }
    if(ucVal == ID_PPPT_EMPTY){
        return ID_EMPTY;
    }
    if(ucVal == ID_PPPT_MATCH){
        return ID_MATCH;
    }
    return ID_ACTIVE;
}

/** \brief Private function used only by the parser. User should never call.
 *
 * \param spCtx Pointer to a parser context.
 * \param spOp Pointer to an opcode.
 * \param uiOffset Offset into the input string of the alphabet character to check the PPPT state of.
 * \return Ture if the state is deterministic, false otherwise
 */
abool bPpptEval(parser* spCtx, const opcode* spOp, aint uiOffset){
    aint uiState = uiPpptState(spCtx, spOp, uiOffset);
    switch(uiState){
    case ID_NOMATCH:
        spCtx->uiOpState = ID_NOMATCH;
        spCtx->uiPhraseLength = 0;
        return APG_TRUE;
    case ID_EMPTY:
        spCtx->uiOpState = ID_MATCH;
        spCtx->uiPhraseLength = 0;
        return APG_TRUE;
    case ID_MATCH:
        spCtx->uiOpState = ID_MATCH;
        spCtx->uiPhraseLength = 1;
        spCtx->uiOffset++;
        return APG_TRUE;
    }
    return APG_FALSE;
}
//static uint8_t s_ucGetMask[4] = {0xC0, 0x30, 0xC,0x3};
//static uint8_t s_ucGetShift[4] = {6,4,2,0};
/* \brief Gets the PPPT values in the map of 2-bit values.
 *
 * Note the use of luint rather than achar. This is because the EOS character is assumed to be acAcharMax + 1.
 * Therefore, depending on the sizeof(achar), it is possible for the EOS character to overflow the achar size.
 * Using luint for the characters here allows the user to request the EOS character without fear of overflow.
 *
 * \param[in] ucpMap - pointer to the map of PPPT values to grammar alphabet characters
 * \param[in] luiOffset - acAcharMin - the value of the lowest characters in the grammar's alphabet set
 * \param[in] luiChar - the character for which to set the PPPT value in the map.
 * \return The 2-bit value as a byte.
 */
/*
uint8_t ucGetMapVal(const uint8_t* ucpMap, luint luiOffset, luint luiChar){
    luint luRelChar = luiChar - luiOffset;
    luint luMapIndex = luRelChar >> 2;
    luint ucByteIndex = luRelChar - (luMapIndex << 2);
    return (ucpMap[luMapIndex] & s_ucGetMask[ucByteIndex]) >> s_ucGetShift[ucByteIndex];
}
*/
uint8_t ucGetMapVal(const uint8_t* ucpMap, luint luiOffset, luint luiChar){
    return ucpMap[luiChar - luiOffset];
//    luint luRelChar = luiChar - luiOffset;
//    luint luMapIndex = luRelChar >> 2;
//    switch(luRelChar % 4){
//    case 0:
//        return (ucpMap[luMapIndex] & 0xC0) >> 6;
//    case 1:
//        return (ucpMap[luMapIndex] & 0x30) >> 4;
//    case 2:
//        return (ucpMap[luMapIndex] & 0xC) >> 2;
//    case 3:
//        return ucpMap[luMapIndex] & 0x3;
//    }
//    return 0;
}
#endif /* APG_NO_PPPT */

